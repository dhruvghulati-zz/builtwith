/**
 * Blog Post endpoints
 * \"Use these endpoints for interacting with Blog Posts, Blog Authors, and Blog Tags\"
 *
 * The version of the OpenAPI document: v3
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/// <reference types="node" />
import http = require('http');
import { BatchInputBlogPost } from '../model/batchInputBlogPost';
import { BatchInputJsonNode } from '../model/batchInputJsonNode';
import { BatchInputString } from '../model/batchInputString';
import { BlogPost } from '../model/blogPost';
import { CollectionResponseWithTotalBlogPostForwardPaging } from '../model/collectionResponseWithTotalBlogPostForwardPaging';
import { CollectionResponseWithTotalVersionBlogPost } from '../model/collectionResponseWithTotalVersionBlogPost';
import { ContentCloneRequestVNext } from '../model/contentCloneRequestVNext';
import { ContentScheduleRequestVNext } from '../model/contentScheduleRequestVNext';
import { VersionBlogPost } from '../model/versionBlogPost';
import { Authentication, Interceptor } from '../model/models';
import { ApiKeyAuth, OAuth } from '../model/models';
export declare enum DefaultApiApiKeys {
    hapikey = 0
}
export declare class DefaultApi {
    protected _basePath: string;
    protected _defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected authentications: {
        default: Authentication;
        hapikey: ApiKeyAuth;
        oauth2: OAuth;
    };
    protected interceptors: Interceptor[];
    constructor(basePath?: string);
    set useQuerystring(value: boolean);
    set basePath(basePath: string);
    set defaultHeaders(defaultHeaders: any);
    get defaultHeaders(): any;
    get basePath(): string;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: DefaultApiApiKeys, value: string): void;
    set accessToken(token: string);
    addInterceptor(interceptor: Interceptor): void;
    /**
     * Delete the Blog Post object identified by the id in the path.
     * @summary Delete a Blog Post
     * @param objectId The Blog Post id.
     * @param archived Whether to return only results that have been archived.
     */
    archive(objectId: string, archived?: boolean, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body?: any;
    }>;
    /**
     * Delete the Blog Post objects identified in the request body. Note: This is not the same as the in-app `archive` function. To perform an in-app `archive` send an normal update with the `archived` field set to true.
     * @summary Archive a batch of Blog Posts
     * @param batchInputString The JSON array of Blog Post ids.
     */
    archiveBatch(batchInputString: BatchInputString, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body?: any;
    }>;
    /**
     * Clone a Blog.
     * @summary Clone a Blog Post
     * @param contentCloneRequestVNext The JSON representation of the ContentCloneRequest object.
     */
    clone(contentCloneRequestVNext: ContentCloneRequestVNext, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: BlogPost;
    }>;
    /**
     * Create a new Blog Post.
     * @summary Create a new Blog Post
     * @param blogPost The JSON representation of a new Blog Post.
     */
    create(blogPost: BlogPost, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: BlogPost;
    }>;
    /**
     * Create the Blog Post objects detailed in the request body.
     * @summary Create a batch of Blog Posts
     * @param batchInputBlogPost The JSON array of new Blog Posts to create.
     */
    createBatch(batchInputBlogPost: BatchInputBlogPost, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: object;
    }>;
    /**
     * Retrieve the Blog Post object identified by the id in the path.
     * @summary Retrieve a Blog Post
     * @param objectId The Blog Post id.
     * @param archived Specifies whether to return archived Blog Posts. Defaults to &#x60;false&#x60;.
     */
    getById(objectId: string, archived?: boolean, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: BlogPost;
    }>;
    /**
     * Retrieve the full draft version of the Blog Post.
     * @summary Retrieve the full draft version of the Blog Post
     * @param objectId The Blog Post id.
     */
    getDraftById(objectId: string, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: BlogPost;
    }>;
    /**
     * Get the list of blog posts. Supports paging and filtering. This method would be useful for an integration that examined these models and used an external service to suggest edits.
     * @summary Get all Blog Posts
     * @param createdAt Only return Blog Posts created at exactly the specified time.
     * @param createdAfter Only return Blog Posts created after the specified time.
     * @param createdBefore Only return Blog Posts created before the specified time.
     * @param updatedAt Only return Blog Posts last updated at exactly the specified time.
     * @param updatedAfter Only return Blog Posts last updated after the specified time.
     * @param updatedBefore Only return Blog Posts last updated before the specified time.
     * @param sort Specifies which fields to use for sorting results. Valid fields are &#x60;name&#x60;, &#x60;createdAt&#x60;, &#x60;updatedAt&#x60;, &#x60;createdBy&#x60;, &#x60;updatedBy&#x60;. &#x60;createdAt&#x60; will be used by default.
     * @param after The cursor token value to get the next set of results. You can get this from the &#x60;paging.next.after&#x60; JSON property of a paged response containing more results.
     * @param limit The maximum number of results to return. Default is 100.
     * @param archived Specifies whether to return archived Blog Posts. Defaults to &#x60;false&#x60;.
     */
    getPage(createdAt?: Date, createdAfter?: Date, createdBefore?: Date, updatedAt?: Date, updatedAfter?: Date, updatedBefore?: Date, sort?: Array<string>, after?: string, limit?: number, archived?: boolean, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: CollectionResponseWithTotalBlogPostForwardPaging;
    }>;
    /**
     * Retrieves a previous version of a blog post.
     * @summary Retrieves a previous version of a blog post
     * @param objectId The Blog Post id.
     * @param revisionId The Blog Post version id.
     */
    getPreviousVersion(objectId: string, revisionId: string, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: VersionBlogPost;
    }>;
    /**
     * Retrieves all the previous versions of a blog post.
     * @summary Retrieves all the previous versions of a blog post
     * @param objectId The Blog Post id.
     * @param after The cursor token value to get the next set of results. You can get this from the &#x60;paging.next.after&#x60; JSON property of a paged response containing more results.
     * @param before
     * @param limit The maximum number of results to return. Default is 100.
     */
    getPreviousVersions(objectId: string, after?: string, before?: string, limit?: number, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: CollectionResponseWithTotalVersionBlogPost;
    }>;
    /**
     * Take any changes from the draft version of the Blog Post and apply them to the live version.
     * @summary Push Blog Post draft edits live
     * @param objectId The id of the Blog Post for which it\&#39;s draft will be pushed live.
     */
    pushLive(objectId: string, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body?: any;
    }>;
    /**
     * Retrieve the Blog Post objects identified in the request body.
     * @summary Retrieve a batch of Blog Posts
     * @param batchInputString The JSON array of Blog Post ids.
     * @param archived Specifies whether to return archived Blog Posts. Defaults to &#x60;false&#x60;.
     */
    readBatch(batchInputString: BatchInputString, archived?: boolean, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: object;
    }>;
    /**
     * Discards any edits and resets the draft to the live version.
     * @summary Reset the Blog Post draft to the live version
     * @param objectId The id of the Blog Post for which it\&#39;s draft will be reset.
     */
    resetDraft(objectId: string, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body?: any;
    }>;
    /**
     * Takes a specified version of a blog post and restores it.
     * @summary Restore a previous version of a blog post
     * @param objectId The Blog Post id.
     * @param revisionId The Blog Post version id to restore.
     */
    restorePreviousVersion(objectId: string, revisionId: string, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: BlogPost;
    }>;
    /**
     * Takes a specified version of a blog post, sets it as the new draft version of the blog post.
     * @summary Restore a previous version of a blog post, to the draft version of the blog post
     * @param objectId The Blog Post id.
     * @param revisionId The Blog Post version id to restore.
     */
    restorePreviousVersionToDraft(objectId: string, revisionId: number, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: BlogPost;
    }>;
    /**
     * Schedule a Blog Post to be Published.
     * @summary Schedule a Blog Post to be Published
     * @param contentScheduleRequestVNext The JSON representation of the ContentCloneRequestVNext object.
     */
    schedule(contentScheduleRequestVNext: ContentScheduleRequestVNext, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body?: any;
    }>;
    /**
     * Sparse updates a single Blog Post object identified by the id in the path. All the column values need not be specified. Only the that need to be modified can be specified.
     * @summary Update a Blog Post
     * @param objectId The Blog Post id.
     * @param blogPost The JSON representation of the updated Blog Post.
     * @param archived Specifies whether to update archived Blog Posts. Defaults to &#x60;false&#x60;.
     */
    update(objectId: string, blogPost: BlogPost, archived?: boolean, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: BlogPost;
    }>;
    /**
     * Update the Blog Post objects identified in the request body.
     * @summary Update a batch of Blog Posts
     * @param batchInputJsonNode
     * @param archived Whether to return only results that have been archived.
     */
    updateBatch(batchInputJsonNode: BatchInputJsonNode, archived?: boolean, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: object;
    }>;
    /**
     * Sparse updates the draft version of a single Blog Post object identified by the id in the path. All the column values need not be specified. Only the that need to be modified can be specified.
     * @summary Update a Blog Post draft
     * @param objectId The Blog Post id.
     * @param blogPost The JSON representation of the updated Blog Post to be applied to the draft.
     */
    updateDraft(objectId: string, blogPost: BlogPost, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: BlogPost;
    }>;
}
