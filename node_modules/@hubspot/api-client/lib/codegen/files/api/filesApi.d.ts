/**
 * Files
 * Upload and manage files.
 *
 * The version of the OpenAPI document: v3
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/// <reference types="node" />
import http = require('http');
import { CollectionResponseFile } from '../model/collectionResponseFile';
import { FileActionResponse } from '../model/fileActionResponse';
import { FileUpdateInput } from '../model/fileUpdateInput';
import { ImportFromUrlInput } from '../model/importFromUrlInput';
import { ImportFromUrlTaskLocator } from '../model/importFromUrlTaskLocator';
import { SignedUrl } from '../model/signedUrl';
import { Authentication, Interceptor } from '../model/models';
import { ApiKeyAuth, OAuth } from '../model/models';
import { RequestFile } from './apis';
export declare enum FilesApiApiKeys {
    hapikey = 0
}
export declare class FilesApi {
    protected _basePath: string;
    protected _defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected authentications: {
        default: Authentication;
        hapikey: ApiKeyAuth;
        oauth2: OAuth;
    };
    protected interceptors: Interceptor[];
    constructor(basePath?: string);
    set useQuerystring(value: boolean);
    set basePath(basePath: string);
    set defaultHeaders(defaultHeaders: any);
    get defaultHeaders(): any;
    get basePath(): string;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: FilesApiApiKeys, value: string): void;
    set accessToken(token: string);
    addInterceptor(interceptor: Interceptor): void;
    /**
     * Delete file by ID
     * @summary Delete file
     * @param fileId File ID to delete
     */
    archive(fileId: string, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body?: any;
    }>;
    /**
     * GDRP delete file
     * @summary GDPR delete
     * @param fileId ID of file to GDPR delete
     */
    archiveGDPR(fileId: string, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body?: any;
    }>;
    /**
     * Check the status of requested import.
     * @summary Check import status.
     * @param taskId Import by URL task ID
     */
    checkImport(taskId: string, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: FileActionResponse;
    }>;
    /**
     * Search through files in the file manager. Does not display hidden or archived files.
     * @summary Search files
     * @param properties Desired file properties in the return object.
     * @param after The maximum offset of items for a given search is 10000. Narrow your search down if you are reaching this limit.
     * @param before
     * @param limit Number of items to return. Maximum limit is 100.
     * @param sort Sort files by a given field.
     * @param id Search files by given ID.
     * @param createdAt Search files by time of creation.
     * @param createdAtLte
     * @param createdAtGte
     * @param updatedAt Search files by time of latest updated.
     * @param updatedAtLte
     * @param updatedAtGte
     * @param name Search for files containing the given name.
     * @param path Search files by path.
     * @param parentFolderId Search files within given folder ID.
     * @param size Query by file size.
     * @param height Search files by height of image or video.
     * @param width Search files by width of image or video.
     * @param encoding Search files with specified encoding.
     * @param type Filter by provided file type.
     * @param extension Search files by given extension.
     * @param url Search for given URL
     * @param isUsableInContent If true shows files that have been marked to be used in new content. It false shows files that should not be used in new content.
     * @param allowsAnonymousAccess If \&#39;true\&#39; will show private files; if \&#39;false\&#39; will show public files
     */
    doSearch(properties?: Array<string>, after?: string, before?: string, limit?: number, sort?: Array<string>, id?: string, createdAt?: Date, createdAtLte?: Date, createdAtGte?: Date, updatedAt?: Date, updatedAtLte?: Date, updatedAtGte?: Date, name?: string, path?: string, parentFolderId?: number, size?: number, height?: number, width?: number, encoding?: string, type?: string, extension?: string, url?: string, isUsableInContent?: boolean, allowsAnonymousAccess?: boolean, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: CollectionResponseFile;
    }>;
    /**
     * Get file by ID.
     * @summary Get file.
     * @param fileId Id of the desired file.
     * @param properties
     */
    getById(fileId: string, properties?: Array<string>, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: any;
    }>;
    /**
     * Generates signed URL that allows temporary access to a private file.
     * @summary Get signed URL to access private file.
     * @param fileId ID of file.
     * @param size For image files. This will resize the image to the desired size before sharing. Does not affect the original file, just the file served by this signed URL.
     * @param expirationSeconds How long in seconds the link will provide access to the file.
     * @param upscale If size is provided, this will upscale the image to fit the size dimensions.
     */
    getSignedUrl(fileId: string, size?: 'thumb' | 'icon' | 'medium' | 'preview', expirationSeconds?: number, upscale?: boolean, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: SignedUrl;
    }>;
    /**
     * Asynchronously imports the file at the given URL into the file manager.
     * @summary Import a file from a URL into the file manager.
     * @param importFromUrlInput
     */
    importFromUrl(importFromUrlInput: ImportFromUrlInput, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: ImportFromUrlTaskLocator;
    }>;
    /**
     * Replace existing file data with new file data. Can be used to change image content without having to upload a new file and update all references.
     * @summary Replace file.
     * @param fileId Id of the desired file.
     * @param file File data that will replace existing file in the file manager.
     * @param charsetHunch Character set of given file data.
     * @param options JSON String representing FileReplaceOptions
     */
    replace(fileId: string, file?: RequestFile, charsetHunch?: string, options?: string, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: any;
    }>;
    /**
     * Update properties of file by ID.
     * @summary update file properties
     * @param fileId ID of file to update
     * @param fileUpdateInput Options to update.
     */
    updateProperties(fileId: string, fileUpdateInput: FileUpdateInput, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: any;
    }>;
    /**
     * Upload a single file with content specified in request body.
     * @summary Upload file
     * @param file File to be uploaded.
     * @param folderId Either \\\&#39;folderId\\\&#39; or \\\&#39;folderPath\\\&#39; is required. folderId is the ID of the folder the file will be uploaded to.
     * @param folderPath Either \\\&#39;folderPath\\\&#39; or \\\&#39;folderId\\\&#39; is required. This field represents the destination folder path for the uploaded file. If a path doesn\\\&#39;t exist, the system will try to create one.
     * @param fileName Desired name for the uploaded file.
     * @param charsetHunch Character set of the uploaded file.
     * @param options JSON string representing FileUploadOptions.
     */
    upload(file?: RequestFile, folderId?: string, folderPath?: string, fileName?: string, charsetHunch?: string, options?: string, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: any;
    }>;
}
